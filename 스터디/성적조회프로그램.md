## 1. Student.class
### 1-1. 필드
- 보안을 위해 private로 선언할 것 ⇒ Getter, Setter로 접근
- 필드명은 본인이 편한대로 작성해도 됨
- ![image](https://user-images.githubusercontent.com/63652571/165560229-513be873-693e-46c2-a00e-2c5b65c52023.png)
### 1-2. 생성자
```java
public Student(int classRoom, String name, int korean, int math, int english) {
    this.classRoom = classRoom;
    this.name = name;
    this.korean = korean;
    this.math = math;
    this.english = english;
}
```
- 매개변수 : 반, 이름, 국어점수, 수학점수, 영어점수
- 번호는 Setter를 통해 나중에 따로 등록할 예정
### 1-3. 메소드
- 모든 필드값에 대하여 Getter, Setter 생성  

## 2. Teacher.class
### 2-1. 필드
- 보안을 위해 private로 선언
- 필드명 자유  
![image](https://user-images.githubusercontent.com/63652571/165560495-ca6566fb-3724-4205-8d6e-3ea5f90dce14.png)
### 2-2. 생성자
- 매개변수 : 아이디, 비밀번호, 이름, 반
### 2-3. 메소드
- 모든 필드값에 대하여 Getter, Setter 생성  

## 3. TeacherService.class
### 3-1. 필드
![image](https://user-images.githubusercontent.com/63652571/165560717-2cbb4db6-44fe-4293-91f6-271fe007eb8c.png)
```java
private static final ArrayList<Teacher> teacherList = new ArrayList<>();
private static final TeacherService teacherService = new TeacherService();
```
- 보안을 위해 private로 선언
- 하나의 객체만 생성해서 접근하기 위해 final 선언
  - final이 붙은 객체는 한 번 선언하면 재할당이 불가능하기 때문에 한 번만 생성할 수 있음
- class 파일이 컴파일 되는 과정에서 메모리에 미리 올려놓기 위해 static 선언
  - static이 붙은 객체는 처음 컴파일 되는 과정에서 메모리에 올라가 객체를 생성하지 않아도 접근할 수 있음
⇒ 결론적으로 private static final은 컴파일 시 메모리에 올라가게 되며, 딱 한번만 할당이 가능하고, 외부 클래스에서 접근을 할 수가 없음 (싱글톤 패턴이라고 부름)
```
*싱글톤 패턴
어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 객체를 만들어 사용하는 디자인 패턴
```
```
*싱글톤 패턴 사용 이유
1. 하나의 객체를 한 번만 생성하기 때문에 메모리를 절약할 수 있음
2. 싱글톤으로 생성된 객체는 전역변수 성질을 갖고 있기 때문에 다른 클래스에서 공유하면서 사용할 수 있음 
⇒ 싱글톤 생성을 하지 않으면 항상 새로운 객체를 생성하는 것이기 때문에 메모리를 많이 사용하게 되며, 다른 클래스와 공유하는 것이 아닌 본인만의 객체를 가지게 됨
```
```
*싱글톤 패턴 단점
멀티 쓰레드 환경에서 서로 접근해 사용하면 문제가 발생함
```
### 3-2. 생성자
```java
private TeacherService() {}
```
- 싱글톤 패턴일 시 객체는 딱 하나만 생성되며, 필드를 private로 선언해 주었기 때문에 외부에서 접근할 수가 없음
- TeacherService는 *생성자를 통한 객체 생성도 막아주기 위해* private로 생성자 작성 → 어차피 우리가 사용할 필드는 이미 컴파일 때 메모리에 올라가 있기 때문에
### 3-3. 메소드
```java
public static TeacherService getInstance() {
    return teacherService;
}
```
- teacherService(TeacherService 객체)는 필드에서 private static final로 선언하면서, 컴파일 될 때 이미 메모리에 올려둠
- 메모리에 올려뒀지만 private로 선언되어 있어서 외부 클래스에서 접근을 하지 못함
- 외부 클래스에서 사용할 수 있도록 하기 위해 getInstance()라는 메소드를 만들어서 teacherService를 리턴해줌 (teacherService의 Getter라고 생각하면 됨)
### 회원가입
```java
public boolean register(String id, String password, String name, int classRoom) {
    for (Teacher teacher : teacherList) {
        if (teacher.getId().equals(id)) {
            return false;
        }
    }

    Teacher teacher = new Teacher(id, name, password, classRoom);
    teacherList.add(teacher);

    return true;
}
```
```java
public boolean register(Teacher teacher) {

    for (Teacher t : teacherList) {
        if (t.getId().equals(teacher.getId())) {
            return false;
        }
    }
    teacherList.add(teacher);

    return true;
}
```
- 회원가입은 이미 등록된 id가 존재하면 회원가입을 하지 못하게 false로 리턴
- 둘 중 하나 편한대로 작성
### 로그인
```java
public Teacher login(String id, String password) {
    for (Teacher teacher : teacherList) {
        if (teacher.getId().equals(id)) {
            if (teacher.getPassword().equals(password))
                return teacher;
            else
                return null;
        }
    }
    return null;
}
```
- 입력받은 id와 password가 같은 Teacher 객체가 존재하면 그 객체를 리턴  
- 
## 4. StudentService.class
### 4-1. 필드
![image](https://user-images.githubusercontent.com/63652571/165561714-de9eec1b-fe46-4438-8250-e7f97f9510e2.png)
```java
private static final ArrayList<Student> studentList = new ArrayList<>();
private static int size = 0;
```
- TeacherService.class와 같은 이유로 private static final 선언
- 학생을 추가할 때마다 size를 1씩 증가하면서 번호로 부여해 줄 것임
### 4-2. 생성자
- 생성자를 생성하지 않으면 컴파일 시 알아서 매개변수가 없는 빈 생성자가 생성이 됨
```java
public StudentService() {} //작성하지 않아도 컴파일 시 알아서 생성
```
- 싱글톤 패턴으로로 작성한 TeacherService와 비교해 보기 위해서 StudentService는 객체를 만들 수 있게 생성자가 생성되게 놔두겠음
### 4-3. 메소드
#### 학생 데이터를 ArrayList<Student>에 추가하는 메소드
```java
public void addStudent(Student student) {
    student.setNo(++size);
    studentList.add(student);
}
```
- 학생을 추가할때마다 size를 1 증가하고 setNo()를 통해 번호를 등록해줌
- size는 static으로 선언되어 있기 때문에 컴파일 때 이미 메모리에 올라가있고, Student 객체를 계속 새로 생성해도 size는 이미 메모리에 올라가 있는 것을 공유해서 사용함.
#### 특정 반 아이들의 정보를 리턴해주는 메소드
```java
public ArrayList<Student> getAll(int classRoom) {
    ArrayList<Student> students = new ArrayList<>();
    for (Student student : studentList) {
        if(student.getClassRoom() == classRoom)
            students.add(student);
    }
    return students;
}
```
- studentList를 for-each문으로 탐색하면서 특정 반인 아이들만 새로운 ArrayList<Student>에 담아서 리턴
#### 특정 반, 특정 한 명의 정보를 리턴해주는 메소드
```java
public Student getOne(int classRoom, String name) {
    for (Student student : studentList) {
        if (student.getClassRoom() == classRoom && student.getName().equals(name))
            return student;
    }
    return null;
}
- studentList를 for-each문으로 탐색하면서 특정 반이면서 특정 이름을 가진 아이만 찾아서 리턴
```
